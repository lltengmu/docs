# 复杂度分析



## 算法效率评估

在算法设计中，我们先后追求以下两个层面的目标。

1. **找到问题解法**：算法需要在规定的输入范围内可靠地求得问题的正确解。
2. **寻求最优解法**：同一个问题可能存在多种解法，我们希望找到尽可能高效的算法。

也就是说，在能够解决问题的前提下，算法效率已成为衡量算法优劣的主要评价指标，它包括以下两个维度。

- **时间效率**：算法运行时间的长短。
- **空间效率**：算法占用内存空间的大小。

简而言之，**我们的目标是设计“既快又省”的数据结构与算法**。而有效地评估算法效率至关重要，因为只有这样，我们才能将各种算法进行对比，进而指导算法设计与优化过程。

效率评估方法主要分为两种：

1. 实际测试

   若要对比两个算法的效率，最直接的方式是直接在一台计算机上运行着这两个算法，监测算法的运行时间和内存占用率。这种评估方式能够反映真实情况，但也存在较大的局限性。

   **局限性：**

   1. **难以排除测试环境的干扰因素**：硬件配置会影响算法的性能表现。比如一个算法的并行度较高，那么它就更适合在多核 `CPU` 上运行，一个算法的内存操作密集，那么它在高性能内存上的表现就会更好。
   2. **展开完整测试非常耗费资源**：随着输入数据量的变化，算法会表现出不同的效率。例如，在输入数据量较小时，算法 `A` 的运行时间比算法 `B` 短；而在输入数据量较大时，测试结果可能恰恰相反。因此，为了得到有说服力的结论，我们需要测试各种规模的输入数据，而这需要耗费大量的计算资源。

2. 理论估算。

   由于实际测试具有较大的局限性，因此我们可以考虑仅通过一些计算来评估算法的效率。这种估算方法被称为渐近复杂度分析（`asymptotic complexity analysis`），简称复杂度分析。

   复杂度分析能够体现算法运行所需的时间和空间资源与输入数据大小之间的关系。**它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势**。这个定义有些拗口，我们可以将其分为三个重点来理解。

   - “时间和空间资源”分别对应**时间复杂度**（`time complexity`）和**空间复杂度**（`space complexity`）。
   - “随着输入数据大小的增加”意味着复杂度反映了**算法运行效率**与**输入数据体量**之间的关系。
   - “时间和空间的增长趋势”表示复杂度分析关注的不是运行时间或占用空间的具体值，而是时间或空间增长的**快慢**。

   **复杂度分析克服了实际测试方法的弊端**，体现在以下几个方面。

   - 它无需实际运行代码，更加绿色节能。
   - 它独立于测试环境，分析结果适用于所有运行平台。
   - 它可以体现不同数据量下的算法效率，尤其是在大数据量下的算法性能。



## 迭代和递归

在算法中，重复执行某个任务是很常见的，它与复杂度分析息息相关。因此，在介绍时间复杂度和空间复杂度之前，我们先来了解如何在程序中实现重复执行任务，即两种基本的程序控制结构：迭代、递归。

1. **迭代**

   迭代（iteration）是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足。

   + **for循环**:

     `for` 循环是最常见的迭代形式之一，**适合在预先知道迭代次数时使用**。

     代码示例:

     ```typescript
     /* for 循环 */
     function forLoop(n: number): number {
         let res = 0;
         // 循环求和 1, 2, ..., n-1, n
         for (let i = 1; i <= n; i++) {
             res += i;
         }
         return res;
     }
     /*
     *此求和函数的操作数量与输入数据大小成正比，
     *或者说成“线性关系”。实际上，时间复杂度描述的就是这个“线性关系”。
     */
     ```

   + **while**循环：

     与 `for` 循环类似，`while` 循环也是一种实现迭代的方法。在 `while` 循环中，程序每轮都会先检查条件，如果条件为真，则继续执行，否则就结束循环。

     下面我们用 `while` 循环来实现求和 1+2+⋯+n ：

     代码示例：

     ```typescript
     /* while 循环 */
     function whileLoop(n: number): number {
         let res = 0;
         let i = 1; // 初始化条件变量
         // 循环求和 1, 2, ..., n-1, n
         while (i <= n) {
             res += i;
             i++; // 更新条件变量
         }
         return res;
     }
     ```

   + 嵌套循环

     在一个循环结构内嵌套另一个循环结构。

     代码示例：

     ```typescript
     /* 双层 for 循环 */
     function nestedForLoop(n: number): string {
         let res = '';
         // 循环 i = 1, 2, ..., n-1, n
         for (let i = 1; i <= n; i++) {
             // 循环 j = 1, 2, ..., n-1, n
             for (let j = 1; j <= n; j++) {
                 res += `(${i}, ${j}), `;
             }
         }
         return res;
     }
     //在这种情况下，函数的 操作数量 与 输入数据 成正比，或者说算法运行时间和输入数据大小成“平方关系”。
     ```

2. 递归：

   递归是一种算法策略，提供函数调用自身来解决问题。它主要包含两个阶段：

   1. **递**：程序不断的调用自身，提供传入更小或者更加简化的参数，直到达到`终止条件`。
   2. **归**：触发`终止条件`后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。

   而从实现的角度看，递归代码包含三个要素。

   1. **终止条件**：用于决定什么时候由**递**转**归**
   2. **递归调用**：对于**递**，函数调用自身，通常输入更小或更简化的参数。
   3. **返回结果**：对应**归**，将当前递归函数的结果返回上一层。

   观察以下代码，我们只需调用函数 `recur(n)` ，就可以完成 1+2+⋯+n 的计算：

   ```typescript
   /* 递归 */
   function recur(n: number): number {
       // 终止条件
       if (n === 1) return 1;
       // 递：递归调用
       const res = recur(n - 1);
       // 归：返回结果
       return n + res;
   }
   ```

   #### 迭代和递归的区别：

   从计算结果来看，迭代和递归都可以实现求和，但是他们代表了两种完全不同的思考问题和解决问题的方式。

   + 从迭代的角度看：迭代是`自下而上`的解决问题。不断的重复和累加基础的步骤直到完成任务。
   + 从递归的角度看：递归是`自上而下`地解决问题，将原问题分解为更小的的子问题，并且子问题和原问题具有相同的形式。就可以将字问题继续分解为更小的问题，知道几情况时停止。

   **调用栈**：

   递归函数每次调用自身时，系统都会为开启新的函数分配内存。以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。

   + 函数的上下文数据都存储在称为 **栈帧空间**的内存区域中，直到函数返回后才会被释放。因此，**递归通常比迭代更加耗费内存空间**。
   + 递归调用函数会产生额外的开销。因此**递归通常比循环的时间效率更低**。

   **尾递归**：

   如果函数在返回前的最后一步才进行递归调用，则该函数可以被编译器或者解释器优化，使其在空间效率上与迭代相当。这种情况称为**尾递归**。

   + 普通递归：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。
   + 尾递归：递归调用时函数返回前的最后一个操作，这意味着函数返回上一层后，无需继续执行其他操作，因此系统无须保存上一层函数的上下文。

   尾递归代码实现：
   ```typescript
   /* 尾递归 */
   function tailRecur(n: number, res: number): number {
       // 终止条件
       if (n === 0) return res;
       // 尾递归调用
       return tailRecur(n - 1, res + n);
   }
   ```



## 时间复杂度

时间复杂度反映执行算法所花费的时间，但是评估算法的时间复杂度不是直接统计算法运行的时间，而是算法的运行时间随着数据量变大时的增长趋势。

推算方法：

+ 统计操作数量：

  