## 工厂模式

- “**工厂模式**” 是一个更宽泛的说法，通常可以指代三种不同的模式：**简单工厂**、**工厂方法模式** 和 **抽象工厂模式**。

### 简单工厂模式

**什么是简单工厂模式？**

**简单工厂模式（Simple Factory Pattern）** 不是 `GoF`（Gang of Four）23 种设计模式之一，但它是一种非常常见且实用的编程技巧。它通过一个**专门的工厂类或函数**来创建对象，将对象的实例化过程集中管理，从而**解耦客户端与具体实现类**。

简单工厂模式的核心就是通过一个工厂方法根据不同的条件生产**同一类型**的产品。

代码示例：

```typescript
//定义抽象基类
abstract class Car {
  abstract fillGas(): void
}

//定义具体的对象类
class Byd implements Car {
  public fillGas(): void {
    console.log('给byd汽车加油')
  }
}

class XiaoMi implements Car {
  public fillGas(): void {
    console.log('给小米汽车加油')
  }
}

//定义一个简单工厂方法
class CarSimpleFactory {
  public static make(brand: string): Car | null {
    let car: Car | null = null
    switch (brand) {
      case 'byd':
        car = new Byd()
        break
      case 'xiaomi':
        car = new XiaoMi()
        break
    }

    return car
  }
}

const xm = CarSimpleFactory.make('xiaomi')
console.log('[ xm ] >')
xm?.fillGas()
const bydInstance = CarSimpleFactory.make('byd')
console.log('[ byd ] >')
bydInstance?.fillGas()
```



### 抽象工厂模式

与“简单工厂”或“工厂方法”不同，抽象工厂关注的是 **产品族（Product Family）** 的一致性，而不是单个对象的创建。

要准确识别出当前场景是在构建哪些产品家族的系列产品对象。

每个产品家族的产品系列生产方法都要在 `AbstractFactory` 接口里面定义。

代码实现：

```typescript
//定义抽象产品<汽车>
abstract class Car {
  abstract name(): void
}
//定义抽象产品<自行车>
abstract class Bike {
  abstract name(): void
}

//定义实际的产品类<byd-car>
class BydCar extends Car {
  public name(): void {
    console.log('byd-car')
  }
}

//定义实际的产品类<byd-bike>
class BydBike extends Bike {
  public name(): void {
    console.log('byd-bike')
  }
}

//定义实际的产品类<byd-bike>
class XiaoMiCar extends Car {
  public name(): void {
    console.log('xiaomi-car')
  }
}

//定义实际的产品类<byd-bike>
class XiaoMiBike extends Bike {
  public name(): void {
    console.log('xiaomi-bike')
  }
}

//定义抽象工厂接口，抽象工厂定义的是一个产品品牌的一系列不同的子产品
abstract class AbstractFactory {
  //子产品 小汽车
  abstract makeCar(): Car
  //子产品 自行车
  abstract makeBike(): Bike
}

//定义具体的品牌工厂类<Byd>
class BydFactory implements AbstractFactory {
  //生产比亚迪汽车
  public makeCar() {
    return new BydCar()
  }
  //生产比亚迪自行车
  public makeBike() {
    return new BydBike()
  }
}

//定义具体的品牌工厂类<xiaomi>
class XiaoMiFactory implements AbstractFactory {
  //生产小米汽车
  public makeCar() {
    return new XiaoMiCar()
  }
  //生产小米自行车
  public makeBike() {
    return new XiaoMiBike()
  }
}

const xiaomiInstance = new XiaoMiFactory()
xiaomiInstance.makeBike().name()

```



### 工厂方法模式

`工厂方法模式`是为了解决`简单工厂模式`出现的问题：

```typescript
//定义一个简单工厂方法
class CarSimpleFactory {
  public static make(brand: string): Car | null {
    let car: Car | null = null
    switch (brand) {
      case 'byd':
        car = new Byd()
        break
      case 'xiaomi':
        car = new XiaoMi()
        break
    }

    return car
  }
}
```



1.工厂函数中列举了所有产品类，如果这个工厂不能运行，比如说在`switch`语句之前报错，那么整个系统都会收到影响。
2.违背 `开放--关闭原则`，一旦添加新的产品就需要修改工厂的代码逻辑，造成工厂逻辑会越来越复杂。

为解决上述问题，采用一种新的设计模式：工厂方法模式。

简单工厂和工厂方法模式的区别是：简单工厂把同一品类的产品都放在一个容器里，通过条件判断来返回不同的产品实例。而工厂方法则是构造一个品牌工厂，通过这个品牌工厂获取其下的具体产品。

代码实现：

```typescript
// 定义抽象产品：汽车
// ✅ 这是工厂方法模式中的 "Product" 角色
abstract class Car {
  abstract name(): void;
}

// 定义具体产品：比亚迪汽车
// ✅ 实现抽象产品的具体类 —— "ConcreteProduct"
class BydCar extends Car {
  public name(): void {
    console.log('byd-car');
  }
}

// 定义具体产品：小米汽车
// ✅ 另一个具体产品实现
class XiaoMiCar extends Car {
  public name(): void {
    console.log('xiaomi-car');
  }
}

// 定义工厂方法接口（创建者）
// ✅ 这是 "Creator" 角色，声明创建产品的工厂方法
// ❌ 不是“抽象工厂”，而是“工厂方法”的抽象定义
abstract class CarFactory {
  // 工厂方法：用于创建汽车对象
  // 子类将重写此方法以返回具体的汽车实例
  // ✅ 这是工厂方法模式的核心 —— 延迟实例化到子类
  abstract createCar(): Car;
}

// 具体工厂：比亚迪汽车工厂
// ✅ 实现工厂方法，返回具体的比亚迪汽车
// 对应 "ConcreteCreator" 角色
class BydFactory extends CarFactory {
  public createCar(): Car {
    return new BydCar();
  }
}

// 具体工厂：小米汽车工厂
// ✅ 同样实现工厂方法，返回小米汽车
class XiaoMiFactory extends CarFactory {
  public createCar(): Car {
    return new XiaoMiCar();
  }
}

// === 客户端使用示例 ===

// 使用工厂方法模式：客户端依赖抽象工厂和抽象产品
const factory: CarFactory = new XiaoMiFactory(); // 可替换为 BydFactory
const car: Car = factory.createCar(); // 创建过程由工厂决定
car.name(); // 输出: xiaomi-car
```

