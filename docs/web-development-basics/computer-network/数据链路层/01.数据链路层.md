# 概述

数据链路层负责通过一条链路从一个节点向另一个物理链路直接相连的相邻节点传送数据报。

## 相关术语

**数据链路**：网络中两个节点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成了数据链路。

**帧**：链路层的协议数据单元，封装网络层数据报。

**透明传输**：是指不管所传输数据是什么样的比特组合，都应当能够在链路上传送。因此，链路层就“看不见”有什么妨碍数据传输的东西。当所传数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的错误，使接收方不会将这样的数据误认为是某种控制信息。这样才能保证数据链路层的传输是透明的。 

## 功能

数据链路层在物理层的提供的服务基础之上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。

1. 为网络层提供服务。无确认无连接服务，有确认有连接服务，有确认面向连接服务。

2. 链路管理：即连接的建立、维持、释放（用于面向连接的服务）。

3. 组帧。

   + 封装成帧：就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。首部和尾部包含许多的控制信息，它们的一个重要作用：**帧定界**（确定帧的界限）。

     **帧同步**：**接收方**应当能从接收到的二进制比特流中区分出帧的起始和终止。

     组帧的四种方法：

     1. 字符计数法

        帧首部使用一个计数字段（第一个字节，八位）来标明帧内字符数。痛点：容易出错，不推荐使用的方法。

     2. 字符（节）填充法

        ![Character-filling-method](/Users/eddie/Documents/code/docs/docs/web-development-basics/computer-network/数据链路层/images/Character-filling-method.png) 

        使用场景：

        1.   当传输的帧是由文本文件组成时（文本文件的字符都是从键盘上输入的，都是`ASCII`码）。不管从键盘上输入什么字符都可以放在帧里传输过去，即`透明传输`。 
        2. 当传送的帧是由非`ASCII`码的文本文件组成时（二进制代码的程序或图像等）。就要采用**字符填充方法实现透明传输**。

        字符填充法的流程：

        ![Character-filling-process](/Users/eddie/Documents/code/docs/docs/web-development-basics/computer-network/数据链路层/images/Character-filling-process.png)

     3. 零比特填充法

        允许数据帧当中包含任意个数的比特。

        图示：

        ![Zero-bit-padding-method](/Users/eddie/Documents/code/docs/docs/web-development-basics/computer-network/数据链路层/images/Zero-bit-padding-method.png)

        与字符填充法的区别在于：标志符的二进制位是一样的，即`01111110`。

        当在数据部分遇到与标志符一样的比特组合时：

        1. 在发送端，扫描整个信息字段，只要连续5个1，就立即填入1个0。
        2. 在接收端收到一个帧时，先找到标志字段确定边界，再用硬件对比比特流进行扫描。发现连续5个1时，就把后面的0删除。

        保证了透明传输：在传送的比特流中可以传送任意比特组合，而不会引起帧边界的判断错误。

     4. 违规编码法

        使用"高-高"，“低-低”的电气电平特性来定界帧的起始和终止。

        由于字节计数法中`Count`字段的脆弱性（其值若有差错将导致灾难性后果）即字符填充实现上的复杂性和不兼容性，目前较普遍使用的帧同步法是`比特填充`和违`规编码法`。

4. 流量控制。 

   `较高的发送速度`和`较低的接收能力`的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作。

   链路层流量控制和传输层流量控制的区别：

   + 数据链路层的流量控制是点对点的（相邻节点之间的流量控制），而传输层的流量控制是端到端的（发送端和接收端）。 
   + 数据链路层流量控制手段：接受方收不下就不回复确认。
   + 传输层流量控制手段：接收端给发送端一个窗口公告。

   流量控制的方法：

   1.  **停止-等待协议**

      每发送完一个帧就停止发送，等待对方的确认，在收到确认后再发送上下一个帧 。

      **为什么要有停止-等待协议？**

      1. 处理比特出差错之外，底层信道还会出现丢包问题。（丢包：物理线路故障、设备故障、病毒攻击、路由信息错误等原因，会导致数据包的丢失）。
      2. 为例实现流量控制。

      **停止-等待协议的前提：**

      + 虽然现在常有双工通信的方式，为了讨论方便，仅考虑一方发送数据，一方接收数据。
      + 因为在讨论可靠性传输原理，所以不考虑数据是在哪一个层次上传递。 

      **优缺点：**

      + 优点：简单
      + 缺点：信道利用率太低

      **求值信道利用率：**

      信道利用率表示发送方在一个发送周期内，有效地发送数据所需的时间占整个发送周期的比率。
      $$
      信道利用率U = \frac{(发送方发送数据帧的时延)T_D}{(发送方发送数据帧的时延)T_D + （往返时延）RTT + （确认帧发送时延）T_A}
      $$
      另一个公式：
      $$
      信道利用率 = (L/C)/T
      $$
      T:发送周期

      L:在发送者周期内发送多少比特数据 

      C:发送方的数据发送速率

      

      信道吞吐率：

      信道吞吐率 = 信道利用率 * 发送方的发送速率

   2. **滑动窗口协议**，又分为两部分：

      + **后退N帧协议（GBN）**

        滑动窗口的概念：

        1. 发送窗口：发送方维持一组连续的允许发送的帧的序列。图示： 

           ![sending-window](/Users/eddie/Documents/code/docs/docs/web-development-basics/computer-network/数据链路层/images/sending-window.png)

           发送方要发送的数据必须要在发送窗口中才能发送。 

        2. 接收窗口：接收方维持一组连续的允许接收帧的序列。图示：

           ![Receiving-Window](/Users/eddie/Documents/code/docs/docs/web-development-basics/computer-network/数据链路层/images/Receiving-Window.png)

        3. GBN发送方必须响应的三件事

           + 上层的调用：上层要发送数据时，发送方先检查发送窗口是否已满，如果未满，则产生一个帧并将其发送，如果窗口已满，发送方只需将数据返回给上次暗示上层已满。上层等一会儿再发送。（实际实现中，发送方可以缓存这些数据，窗口不满时再发送帧）。
           + 收到一个ACK（接收端发送的确认帧）：GBN协议中，对n号帧的确认采用累计确认的方式，标明接收方已经收到n号帧和它之前的全部帧。
           + 超时事件：协议的名字为后退N帧/回退N帧，来源于出阿羡丢失和时延过长时发送方的行为。就像在停止-等待协议中一样，定时器将再次用于恢复数据帧或确认帧的丢失。如果出现超时，发送方重传所有已发送但未被确认的帧。

        4. 接收方要做的事

           + 正确接收的情况：如果正确收到n号帧，并且排序，那么接收方为n帧发送一个ACK，并将该帧中的数据部分交付给上层。
           + 数据丢失的情况：其余情况都丢弃帧，并为最近按序接收的帧重新发送ACK。接收方无需缓存任何失序帧，只需要维护一个信息：`expectedseqnum`（下一个按序接收的帧序号）。

        **完整流程：**

        ![The-complete-process-of-GBN](/Users/eddie/Documents/code/docs/docs/web-development-basics/computer-network/数据链路层/images/The-complete-process-of-GBN.png)

        对滑动窗口的思考：滑动窗口可以无限大吗？

        若采用n个比特对帧编号，那么发送窗口的尺寸W~T~应满足：1<= W~T~<= 2^n^-1。因为发送窗口尺寸过大，就会使得接收方无法区别新帧和旧帧。

        总结：

        1. 累积确认（偶尔捎带确认）
        2. 接收方只按顺序接收帧，不按序无情丢弃
        3. 确认序列号最大的，按序到达的帧
        4. 发送窗口最大为2^n^-1，接收窗口为1。 

      + **选择重传协议（SR）**:

        1. SR发送方必须响应的三件事
           + 上层的调用：从上层收到数据之后，SR发送方检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送数据帧，否则就像GBN一样，要么将数据缓存，要么返回给上层之后再传输。
           + 收到一个ACK：加入该帧序号在窗口内，则SR发送方将那个被确认的帧标记为已接收。如果该帧序号事窗口的下届（最左边第一个窗口对应的序号），则窗口向前移动道具有最小序号的未确认处。如果窗口移动了并且有序号在窗口内的未发送帧，则发送这些帧。
           + 超时事件：每个帧都有自己的定时器，一个超时事件发生后只重传一个帧
        2. 接收方要做的事
           + SR接收方将确认一个正确接收的帧而不管其是否按序。失序的帧将被缓存，并返回给发送方一个该帧的确认帧【收谁确认谁】，直到所有帧（即序号更小的帧）皆被收到为止，这时才可以将一批帧按序交付给上层，然后向前移动滑动窗口。
        
        总结：
        
        1. 对数据帧逐一确认，收一个确认一个
        
        2. 只重传出错帧
        
        3. 接收方有缓存
        
        4. 最大滑动窗口长度
           $$
           w_{T max} = w_{R max} = 2^{n-1}
           $$
            

   **可靠传输、滑动窗口、流量控制之间的关系：**

   可靠传输：发送端发送啥接收端收啥。

   流量控制：控制发送速率，使接收方有足够的缓冲空间来接收每一帧。

   滑动窗口解决：

   1. 流量控制（收不下就不给确认，想发也发不了）
   2. 可靠传输（发送方自动重传）

5. 差错控制（帧错/位错）。

   **差错从何而来？**

   概括来说，传输中的差错都是由于噪声引起的。

   **全局性**：由于线路本身电气特性所产生的随机噪声，是信道固有的，随机存在的。解决办法：提高信噪比来减少或避免干扰。

   **局部性**：外界特定的短暂原因所造成的冲击噪声，是产生差错的主要原因。解决办法，通常利用编码技术来解决。

   **会产生哪些差错**：

   1. 位错：比特位出错，1变成0，0变成1。
   2. 帧错：
      + 丢失：收到[#1]-[#3]
      + 重复：收到[#1]-[#2]-[#2]-[#3]
      + 失序：收到[#1]-[#3]-[#2]

   **差错控制**：分为两部分

   1. 检错编码：

      数据链路层编码和物理层的数据编码与调制不同。物理层编码针对的是**单个比特**，解决传输过程中比特的同步等问题，如曼彻斯特编码。而数据链路层的编码针对的是一组比特，它通过冗余码的技术实现一组二进制比特串在传输过程是否出现了差错。

      **冗余编码**：在数据发送之前，先按某种关系附加上一定的冗余位，构成一个符合某一规则的码字后再发送。当要发送的有效数据变化时，相应的冗余位也随之变化，使码字遵从不变的规则。接收端根据收到码字是否仍符合规则，从而判断是否出错。

      检错编码分为两种：

      + **奇偶校验码**

        n -1 位信息元，1位检验元。

        + 奇校验码：在 n-1 位信息元之前加上一个校验元，使得“1”的个数为奇数
        + 偶检验码：在 n-1 位信息元之前加上一个校验元，使得“1”的个数为偶数

        特点：只能检查出奇数个比特错误，检查能力为50%。

      + **CRC--循环冗余码**：

        CRC循环冗余码利用除法及余数的原理，实现错误侦测的功能。

        1. 数据表示：传输的数据首先是一个数据比特流。
        2. 生成多项式：CRC使用生成多项式是固定的，用于进行多项式除法运算。
        3. 冗余码：通过多项式除法运算得到的余数即为CRC检验码，也称冗余码。这个余数会作为冗余信息附加到原始数据末尾，一起发送给接受方。

        **例子**：要发送的数据是 `1101 0110 11`，采用CRC检验，生成多项式是`10011`，那么最终发送的数据应该是？

        最终发送的数据 = 原始数据 + 帧检验序列FCS

        计算冗余码的步骤：

        1. 加0，假设生成多项式G(x)的最高阶为r,则加r个0.
        2. 模2除法。数据加0之后除以多项式，余数为冗余码 FCS。

        `10011` 表示成多项式为：x^4^+x^1^+x^0^ = x^4^+x^1^+1

        阶为4。tip:多项式N位，阶为 N-1。

        `10011`表示为多项式为什么是：x^4^+x^1^+x^0^，通过以下推导而来：

        `10011`表示5位二进制数据，则最高阶为：5-1 = 4，函数表达式自变量最高阶的幂为4，完整表达式为：(1* x^4^)+(0 * x^3^) + (0 * x^2^)+ (1 * x^1^) + (1 * x^0^)

        在这个例子中最该阶是 4，对原始数据补0得到`1101 0110 11 0000`，再除以生成多项式`10011`（二进制除法不深入研究，应该不难），得道余数`1101`就是FCS冗余码。然后再原始数据末尾添加冗余码得到`1101 0110 11 1101`就是发送出去的数据。

        接收端检错过程：

        把收到的每一个帧都除以同样的除数，然后检查得到的余数R。

        1. 余数为0，判定这个帧没有差错，接受。
        2. 余数不为0，判定这个帧由差错，但是无法确定到 `位`，丢弃。

        FCS的生成以及接收端CRC检验都是硬件实现，处理很迅速，因此不会延误数据的发送。

        

   2. 纠错编码

      + 海明码：

        **前置概念**

        1. 海明距离：两个合法编码（码字）的对应比特取值不同的比特数称为这个两个码字的海明距离（码距），一个有效编码集中，任意两个合法编码（码字）的海明距离的最小值称为该编码集的**海明距离（码距）**。

        海明码特点：

        1. 发现错误
        2. 找到位置
        3. 纠正错误

        海明码工作流程：

        1. 确定检验码位数r

           如果数据/信息由m位，冗余码/检验码有r位，则检验码一共有2^r^种取值。

           海明不等式：
           $$
           r^2 \geqq  m + r + 1
           $$
           例子：要发送的数据：D = 1100

           数据的位数：m = 4，

           满足不等式的最小r为3，也就是D=1100的海明码应该有4 + 3 = 7 位，其中原始数据4位，检验码3位。

        2. 确定检验码和数据的位置

           D=1100

           检验码放在序号位2^n^的位置，数据按序填上

           | 序号 | 7    | 6    | 5    | 4    | 3    | 2    | 1    |
           | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
           | 值   | 1    | 1    | 0    | X~4~ | 0    | x~2~ | x~1~ |

           

        3. 求出检验码的值

           | 二进制 | 111  | 110  | 101  | 100  | 011  | 010  | 001  |
           | ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
           | 序号   | 7    | 6    | 5    | 4    | 3    | 2    | 1    |
           | 值     | 1    | 1    | 0    | X~4~ | 0    | x~2~ | x~1~ |

           4号检验码负责4,5,6,7的检验

           2号检验码负责2,3,6,7的检验

           1号检验码负责1,3,5,7的检验

           推导验证码的值，采用偶检验，

           + 推导x~4~的值：4号检验码负责4,5,6,7的检验，则4,5,6,7位的组合要形成偶数个1，已知5,6,7位分别为 0,1,1所以x~4~为0，
           + 推导x~2~的值：2号检验码负责2,3,6,7的检验，则2,3,6,7位的组合要形成偶数个1，已知3,6,7位分别为 0,1,1所以x~4~为0，
           + 推导x~1~的值：1号检验码负责1,3,5,7的检验，则1,3,5,7位的组合要形成偶数个1，已知3,5,7位分别为 0,0,1所以x~4~为1，

           就可以得到完整的海明码为：

           | 序号 | 7    | 6    | 5    | 4    | 3    | 2    | 1    |
           | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
           | 值   | 1    | 1    | 0    | 0    | 0    | 0    | 1    |

        4. 检错并纠错  

           若接受方收到的数据为`1110001`，检错类似奇偶校验。这里采用偶校验（二进制组合具有偶数个1）。

           4号检验码负责4,5,6,7的检验 => 0，1，1，1 => 不符合偶校验

           2号检验码负责2,3,6,7的检验 => 0，0，1，1 =>  符合偶校验

           1号检验码负责1,3,5,7的检验 =>1，0，1，1 =>   不符合偶校验

           得出结论：接收端接收到的数据出现了差错。

           **如何纠错：**

           1. 找到不满足奇/偶检验的分组取交集，并与符合检验的分组取差集 。

           2. x~4~，0，1，1，1  => x~4~ = 1

              x~2~，0，0，1，1  =>x~2~ = 0

              x~1~，1，0，1，1  => x~1~ = 1

              将101转成10进制数得5，推断出第5位比特数出错了。

              

              

    
