## Vue Api



### Vue的响应式陷阱

#### 解构失效

```typescript
<script setup lang="ts">
import { reactive } from "vue";

const user = reactive({ name: "Eddie" });
//解构之后丢失响应式变量
let { name } = user;

//Vue无法追踪变量 name 的变化
setTimeout(() => name = 'Hobs', 3000);
</script>

<template>
  <div>{{ name }}</div>
</template>
```

要么不要进行解构，如一定要进行解构则可以使用`toRefs` api对响应式数据进行包裹。如下：

```typescript
<script setup lang="ts">
import { reactive, toRefs } from "vue";

const user = reactive({ name: "Eddie" });
let { name } = toRefs(user);

//Vue依然能追踪到 name 属性的变化
setTimeout(() => name.value = 'Hobs', 3000);
</script>

<template>
  <div>{{ name }}</div>
</template>
```



#### `Ref` 对象的整体替换

不会式丢失响应性，但是会触发Vue重新追踪响应式依赖。

```typescript
let state = ref({ count: 0 });

state.value = {
  ...state.value,
  count: state.value.count + 1,
};
```

