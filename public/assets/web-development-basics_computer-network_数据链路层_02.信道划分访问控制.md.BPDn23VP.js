import{_ as o,c as e,o as l,ae as i}from"./chunks/framework.Dh1jimFm.js";const a="/assets/The-impact-of-propagation-delay-on-carrier-monitoring.CJ7QJlZu.png",g=JSON.parse('{"title":"信道划分介质访问控制","description":"","frontmatter":{},"headers":[],"relativePath":"web-development-basics/computer-network/数据链路层/02.信道划分访问控制.md","filePath":"web-development-basics/computer-network/数据链路层/02.信道划分访问控制.md","lastUpdated":1747321547000}'),c={name:"web-development-basics/computer-network/数据链路层/02.信道划分访问控制.md"};function t(r,p,d,n,s,u){return l(),e("div",null,p[0]||(p[0]=[i('<h1 id="信道划分介质访问控制" tabindex="-1">信道划分介质访问控制 <a class="header-anchor" href="#信道划分介质访问控制" aria-label="Permalink to &quot;信道划分介质访问控制&quot;">​</a></h1><h2 id="传输数据使用的两种链路" tabindex="-1">传输数据使用的两种链路 <a class="header-anchor" href="#传输数据使用的两种链路" aria-label="Permalink to &quot;传输数据使用的两种链路&quot;">​</a></h2><h4 id="点对点链路" tabindex="-1">点对点链路 <a class="header-anchor" href="#点对点链路" aria-label="Permalink to &quot;点对点链路&quot;">​</a></h4><p>两个相邻节点通过一个链路相连，没有第三者。</p><p>应用：<code>PPP</code>协议，常用与<strong>广域网</strong>。</p><h4 id="广播式链路" tabindex="-1">广播式链路 <a class="header-anchor" href="#广播式链路" aria-label="Permalink to &quot;广播式链路&quot;">​</a></h4><p>所有主机共享通信介质。 应用：早期的总线以太网，无线局域网，常用于<strong>局域网</strong></p><h2 id="介质访问控制" tabindex="-1">介质访问控制 <a class="header-anchor" href="#介质访问控制" aria-label="Permalink to &quot;介质访问控制&quot;">​</a></h2><p>解决的问题：当多个设备共享同一通信介质，比如（以太网总线，WIFI无线信道）时，如果多个设备同时发送数据，就会导致冲突或干扰，从而造成数据丢失或重传，降低网络效率。</p><p>介质访问控制就是，采取一定的措施，使得两对节点之间的通信不会发生互相干扰的情况。</p><p><code>多路复用技术</code>：把多个信号组合在一条物理信道上进行传输，使得多个计算机或终端设备共享信道资源提高信道利用率。把一条广播信道，逻辑上分成几条用于两个节点之间通信的互不干扰的子信道，实际就是把广播信道转变为点对点信道。</p><p>分为两部分：</p><h4 id="静态划分信道-信道划分介质访问控制-mac-multiple-access-control" tabindex="-1">静态划分信道（信道划分介质访问控制（MAC Multiple Access Control）） <a class="header-anchor" href="#静态划分信道-信道划分介质访问控制-mac-multiple-access-control" aria-label="Permalink to &quot;静态划分信道（信道划分介质访问控制（MAC Multiple Access Control））&quot;">​</a></h4><p>将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开，把<code>时域和频域资源合理</code>的分配给网络上的设备。</p><p>基于多路复用技术：把多个信号组合在一条物理信道上进行传输，使得多个计算机或终端设备共享信道资源，提高信道利用率。把一条广播信道，逻辑上分成几条用于两个节点之间通信的互不干扰的子信道，实际就是把广播信道转变为点对点信道。</p><p><strong>四种介质访问控制手法</strong>：</p><ol><li><p>频分多路复用 <code>FDM</code>（Frequency Division Multiplexing）：</p><p>将信道的总频带划分为多个<code>子频带</code>，每个子频带作为一个子信道，每对用户使用一个子信道进行通信。</p><p>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样时间占用不同的带宽（频率带宽）资源。</p><p>优点：充分利用传输介质带宽，系统效率较高。由于技术比价成熟，实现也比较容易。</p></li><li><p>时分多路复用 <code>TDM</code>：</p><p>将时间划分为一段段等长的时分复用帧（<code>TDM帧</code>）。每一个时分复用的用户在每一个<code>TDM帧</code>中占用固定序号的时隙，所有用户轮流占用信道。</p><p><code>TDM帧</code>：是在物理层传送的比特流所划分的帧，标志一个周期。</p><p><strong>统计时分复用（改进的时分复用）<code>STDM</code></strong>：</p><p>每格<code>STDM</code>帧中的时隙数小于连接在集中器上的用户数。各用户有了数据就随时发往集中器的输入缓存，然后集中器按顺序依次扫描输入缓存，把缓存中的输入数据放入<code>STDM</code>帧中，一个<code>STDM</code>帧满了就发出。<code>STDM</code>帧不是固定分配时隙，而是按需动态分配时隙。</p></li><li><p>波分多路复用 <code>WDM</code>（wavelength Division Multiplexing）：</p><p>波分多路复用就是光的频分多路复用，在一个光纤中传输多种不同波长（频率）的光信号，由于波长（频率）不同，所以各路光信号互不干扰，最好再用波长分解复用器将各路波长分解出来。</p></li><li><p>码分多路复用 <code>CDM</code>（Code Division Multiplexing）：</p><p>码分多路复用技术允许多个用户共享一段频率和时间资源（多个用户在同一时间，同一带宽频率下传输数据）。通过给每个用户分配一个唯一的<code>编码序列</code>来区分不同的信号。</p></li></ol><h4 id="动态分配信道" tabindex="-1">动态分配信道 <a class="header-anchor" href="#动态分配信道" aria-label="Permalink to &quot;动态分配信道&quot;">​</a></h4><p>动态媒体接入控制/多点接入</p><p>特点：信道并非在用户通信时固定分配给用户。</p><p>分为两部分：</p><p>轮询访问介质访问控制：令牌传递协议</p><p>随机访问介质访问控制：</p><p>所有用户可随机发送信息。发送信息时可占全部带宽。</p><ul><li><p><code>ALOHA</code>协议</p><ol><li><p>纯ALOHA协议：不监听信道，不按时间槽发送，随机重发。</p><p>工作原理：</p><ul><li>站点（节点）只要有数据帧要发送，就立即发送到信道上。</li><li>接收方收到数据帧之后发送一个确认帧（ACK）。</li><li>法如果发送方没有收到确认帧，则认为发生了冲突，然后随机延迟一段时间再重传。</li></ul></li><li><p>时隙ALOHA协议（ALOHA改进版本）：把时间分层若干个相同的时间片，所有用户在时间片开始时刻同步介入网络信道，若发生冲突，则必须等到下一个时间片开始再发送。</p><ol><li>纯ALOHA协议比时隙ALOHA吞吐量更低，效率更低。 <ol><li>纯ALOHA想发就发，时隙ALOHA只有在时间片段开始时才能发。</li></ol></li></ol></li></ol></li><li><p><code>CSMA</code>协议（载波监听多路访问协议<code>CSMA</code>）：</p><p>CS：载波侦听/监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据。</p><p>当几个站同时再总线上发送数据时，总线上的信号<code>电压摆动值</code>将会增大（互相叠加）。当一个站检测到的信号电压摆动值超过一定限值时，就认为总线上至少有两个站在同时发送数据，表明产生了碰撞（即发生了冲突）。</p><p>MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。</p><p>协议思想：发送帧之前，先监听信道。</p><p>监听结果：</p><ul><li>信道空闲：发送完整帧</li><li>信道忙：推迟发送（推迟时间根据以下三种协议各有不同）</li></ul><p>三种协议：</p><ul><li><code>1-坚持CSMA</code>：</li></ul><p>坚持指的是对于监听信道忙之后的坚持。</p><p>思想：如果一个主机要发送消息，那么它先监听信道。空闲则直接传输，不需要等待。忙则一直监听，直到空闲马上传输。</p><p>如果有冲突（一段时间内未收到肯定回复），则等待一个随机长的时间再监听，重复上述过程。</p><p>优点：只要媒体空闲，站点就马上发送，避免了媒体利用率的损失。</p><p>缺点：假如有两个或两个以上的站点有数据要发送，冲突就不可避免。</p><ul><li><p><code>非坚持CSMA</code>：非坚持指的是对于监听信道忙之后就不继续监听。</p><p>非坚持<code>CSMA</code>思想：如果一个主机要发送消息，那么它先监听信道。空闲则直接传输，必须要等待。忙则等待一个随机时间之后再进行监听。</p><p>优点：采用随机的重发延迟时间可以减少冲突发生的可能性。</p><p>缺点：可能存在大家都在延迟等待过程中，使得媒体仍可能处于空闲状态，媒体利用率降低。</p></li><li><p><code>p-坚持CSMA</code>：</p><p>p-坚持指的是对于监听信道空闲的处理。</p><p>p-坚持<code>CSMA</code>思想：如果一个主机要发送信息，那么它先监听信道。</p><p>空闲则以p概率直接传输，不必等待。概率1-p等待到下一个时间再传输。</p><p>忙则持续监听直到信道空闲再以p概率发送。</p><p>若冲突则等待到下一个时间槽开始再监听并重复上述过程。</p><p>优点：既能像非坚持算法那样减少冲突，又能像1-坚持算法那样减少媒体空闲时间的这种方案。</p><p>缺点：发生冲突之后还是坚持把数据帧发送完，造成浪费。</p></li></ul></li><li><p><code>CSMA/CD协议</code>（重点）：</p><p><strong>CS</strong>:载波侦听/监听，没一个站在<code>发送数据之前</code>以及<code>发送数据时</code>都要检测总线上是否与其他计算机在发送数据。</p><p><strong>MA</strong>:多点接入（“<strong>多点接入</strong> ”是指多个设备（站点、主机）<strong>共享同一个通信信道</strong> ，即它们都连接到同一个局域网段上，可以在这个信道上传输和接收数据。），表示许多计算机以多点接入的方式连接在一根总线上。</p><p><strong>CD</strong>：碰撞检测（冲突检测），“边发送边监听”，适配器发送数据边检测信道上信号电压的变化情况，以便判断自己再发送数据时其他站是否也在发送数据。</p><p>思考：先听后发为什么会冲突？</p><p>因为电磁波在总线上总是以有限的速率传播的。</p><p><strong>传播时延对载波监听的影响</strong></p><p><img src="'+a+'" alt="The-impact-of-propagation-delay-on-carrier-monitoring"></p><p><strong>如何确定碰撞后的重传时机</strong></p><p>使用截断二进制指数规避算法</p><ol><li>确定基本退避（推迟）时间争用期2τ。</li><li>定义参数k,它等于重传次数，但k不超过10,即k = min[重传次数，10]。当重传次数不超过10时，k等于重传次数，当重传次数大于10时，k就不再增大而一直等于10。</li><li>从离散的整数集合[0,1,2^k^ - 1]中随机取出一个数r，重传所需要退避的时间就是r倍的基本退避时间，即2rτ。</li><li>当重传16次仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错。</li></ol><p><strong>最小帧长问题</strong></p><p>帧在发送完毕之后才检测到发生了碰撞。</p><p><code>最小帧长</code>：帧的传输时延至少要两倍于信号在总线中的传播时延。</p><p>帧长/数据传输速率 &gt;= 2τ</p><p>最小帧长 = 总线传播时延 x 数据传输速率 x 2 = 2τ x 数据传输速率</p></li><li><p><code>CSMA/CA协议</code>（了解即可）。</p></li></ul>',25)]))}const A=o(c,[["render",t]]);export{g as __pageData,A as default};
