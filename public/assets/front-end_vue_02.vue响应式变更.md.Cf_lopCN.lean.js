import{_ as t,c as o,a0 as i,o as p}from"./chunks/framework.CoVXEd1Z.js";const y=JSON.parse('{"title":"Vue响应式原理中， Object.definePropty有什么缺陷？为什么在Vue3.0采用了Proxy，抛弃了Object.definePropty?","description":"","frontmatter":{},"headers":[],"relativePath":"front-end/vue/02.vue响应式变更.md","filePath":"front-end/vue/02.vue响应式变更.md","lastUpdated":null}'),a={name:"front-end/vue/02.vue响应式变更.md"};function r(d,e,l,s,c,n){return p(),o("div",null,e[0]||(e[0]=[i('<h1 id="vue响应式原理中-object-definepropty有什么缺陷-为什么在vue3-0采用了proxy-抛弃了object-definepropty" tabindex="-1">Vue响应式原理中， Object.definePropty有什么缺陷？为什么在Vue3.0采用了Proxy，抛弃了Object.definePropty? <a class="header-anchor" href="#vue响应式原理中-object-definepropty有什么缺陷-为什么在vue3-0采用了proxy-抛弃了object-definepropty" aria-label="Permalink to &quot;Vue响应式原理中， Object.definePropty有什么缺陷？为什么在Vue3.0采用了Proxy，抛弃了Object.definePropty?&quot;">​</a></h1><h2 id="object-definepropty" tabindex="-1">Object.definePropty <a class="header-anchor" href="#object-definepropty" aria-label="Permalink to &quot;Object.definePropty&quot;">​</a></h2><p>该方法允许精确地添加或修改对象的属性，并返回对象。默认情况下此方法添加的属性是不可修改的。</p><p>用法：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">definePropty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj,prop,descriptor)</span></span></code></pre></div><p>返回值：返回更新或者添加属性后的<code>obj</code>对象。</p><p>参数：</p><ul><li><p><code>obj</code>：要定义属性的对象。</p></li><li><p><code>prop</code>：要添加或修改的属性名。</p></li><li><p><code>descriptor</code>：属性描述符对象。</p><p>包含以下属性的对象：</p><p><code>value</code>：属性的值，默认值是<code>undefined</code></p><p><code>writable</code>：属性是否可写。默认值是<code>false</code></p><p><code>enumerable</code>：属性的可枚举性，默认值是<code>false</code>，即属性不可枚举（或者说目标属性在 for…in、Object.keys、JSON.stringify 中是否可遍历）。</p><p><code>configurable</code>：属性的可配置性。默认为<code>false</code>，即属性不可被删除。</p><p><code>get</code>：获取属性值的函数。</p><p><code>set</code>：设置属性值的函数。</p></li></ul><p>注意：</p><p><code>Object.defineProperty</code>设置了<code>getter</code>和<code>setter</code>之后，就不能设置<code>value</code>属性。否则报错：</p><p><code>Uncaught TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute,</code></p><h2 id="proxy" tabindex="-1">Proxy <a class="header-anchor" href="#proxy" aria-label="Permalink to &quot;Proxy&quot;">​</a></h2><p><code>Proxy</code>对象创建一个<strong>对象的代理</strong>，从而实现基本操作的拦截和自定义。</p><p>用法：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> _my_proxy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target,handler)</span></span></code></pre></div><p>参数：</p><ul><li><p><code>target</code>：需要被代理的对象。通常是引用数据类型（数组，函数，对象等）。</p></li><li><p><code>handler</code>：一个配置对象，具有以下配置选项。</p><ul><li><p>handler.apply()</p></li><li><p>handler.construct()</p></li><li><p>handler.defineProperty()</p></li><li><p>handler.deleteProperty()</p></li><li><p>handler.get() 拦截对象属性的读写操作。</p></li><li><p>handler.getOwnPropertyDescriptor()</p></li><li><p>handler.getPrototypeOf()</p></li><li><p>handler.has() 拦截<code>in</code>操作符，判断对象是否包含某个属性。</p></li><li><p>handler.isExtensible()</p></li><li><p>handler.ownKeys()</p></li><li><p>handler.preventExtensions()</p></li><li><p>handler.set() 拦截对象属性的赋值操作。</p></li><li><p>handler.setPrototypeOf()</p></li></ul></li></ul><h2 id="object-definepropty有什么缺陷" tabindex="-1">Object.definePropty有什么缺陷？ <a class="header-anchor" href="#object-definepropty有什么缺陷" aria-label="Permalink to &quot;Object.definePropty有什么缺陷？&quot;">​</a></h2><ol><li>无法监听数组的变化。</li><li>无法监听对象属性的添加或删除</li><li>性能问题：这个api需要递归遍历对象的所有属性并为其添加<code>getter</code>和<code>setter</code>，者在对象负责或者嵌套层级较深时会影响性能。</li></ol><h2 id="proxy的优势" tabindex="-1">Proxy的优势 <a class="header-anchor" href="#proxy的优势" aria-label="Permalink to &quot;Proxy的优势&quot;">​</a></h2><ol><li>全面监听对象和数组</li><li>性能提升：Proxy在对象层级较深时，只在访问属性时才会进行代理，性能更好。</li></ol><p>Vue 3.0采用<code>Proxy</code>替代<code>Object.defineProperty</code>，主要因为<code>Proxy</code>能更全面、高效地监听对象和数组的变化，解决了<code>Object.defineProperty</code>在数组监听、属性增删和性能上的缺陷，同时提供了更好的扩展性和兼容性。</p>',22)]))}const u=t(a,[["render",r]]);export{y as __pageData,u as default};
