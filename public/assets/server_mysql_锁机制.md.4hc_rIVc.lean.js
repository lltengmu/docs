import{_ as a,c as n,a0 as e,o as i}from"./chunks/framework.CoVXEd1Z.js";const r=JSON.parse('{"title":"锁机制","description":"","frontmatter":{},"headers":[],"relativePath":"server/mysql/锁机制.md","filePath":"server/mysql/锁机制.md","lastUpdated":1734360942000}'),p={name:"server/mysql/锁机制.md"};function l(t,s,d,o,c,h){return i(),n("div",null,s[0]||(s[0]=[e(`<h1 id="锁机制" tabindex="-1">锁机制 <a class="header-anchor" href="#锁机制" aria-label="Permalink to &quot;锁机制&quot;">​</a></h1><h2 id="选择存储引擎" tabindex="-1">选择存储引擎 <a class="header-anchor" href="#选择存储引擎" aria-label="Permalink to &quot;选择存储引擎&quot;">​</a></h2><p><code>InnoDB</code> 是主流储存引擎并支持行级锁的，有更高的并发处理性能，下面来演示行锁的运行过程。</p><ul><li>行锁开销大，锁表慢</li><li>行锁高并发下可并行处理，性能更高</li><li>行锁是针对索引加的锁，在通过索引检索时才会应用行锁，否则使用表锁</li><li>在事务执行过程中，随时都可以执行锁定，锁在执行 COMMIT 或者 ROLLBACK 的时候释放</li></ul><h2 id="事务处理" tabindex="-1">事务处理 <a class="header-anchor" href="#事务处理" aria-label="Permalink to &quot;事务处理&quot;">​</a></h2><ol><li>A 事务执行以下代码但不提交</li></ol><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BEGIN;</span></span>
<span class="line"><span>UPDATE stu SET sname = &#39;hdcms&#39; WHERE id=1;</span></span></code></pre></div><ol start="2"><li><p>B 事务执行以下代码，可以正常执行</p><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BEGIN;</span></span>
<span class="line"><span>update stu set sname = &#39;后盾人&#39; where id=3</span></span>
<span class="line"><span>COMMIT;</span></span></code></pre></div></li><li><p>B 事务更新与 A 事务相同的记录则无法操作，执行过程发生阻塞</p><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BEGIN;</span></span>
<span class="line"><span>UPDATE stu SET sname = &#39;hdcms&#39; WHERE id=1;</span></span>
<span class="line"><span>...</span></span></code></pre></div></li><li><p>当 A 执行执行<code>COMMIT</code> 提交后，解锁记录行这时 B 事务继续执行</p><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>...</span></span>
<span class="line"><span>COMMIT;</span></span>
<span class="line"><span>...</span></span></code></pre></div></li></ol><h4 id="非索引阻塞" tabindex="-1">非索引阻塞 <a class="header-anchor" href="#非索引阻塞" aria-label="Permalink to &quot;非索引阻塞&quot;">​</a></h4><p>使用非索引字段筛选时，将造成全表锁定即表级锁，应该避免这种情况发生，提升数据库的并发性能。</p><ol><li><p>事务 A 执行以下代码，因为<code>sname</code>字段没有添加索引，造成锁定整个表</p><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BEGIN;</span></span>
<span class="line"><span>UPDATE stu SET sname = &#39;hdcms&#39; WHERE sname =&#39;后盾人&#39;;</span></span></code></pre></div></li><li><p>现在事务 B 更新任何一条记录都会造成阻塞，因为现在是表锁状态</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BEGIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">update stu set sname </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;小明&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> where id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 阻塞中</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span></span></code></pre></div></li><li><p>将 <code>sname</code>字段添加索引后，行锁功能就又有效了</p></li></ol><h4 id="范围锁" tabindex="-1">范围锁 <a class="header-anchor" href="#范围锁" aria-label="Permalink to &quot;范围锁&quot;">​</a></h4><p>查询没有指定明确范围时也会造成大量记录的锁定</p><ol><li><p>事务 A 筛选时使用了范围区间，将会造成表锁</p><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BEGIN;</span></span>
<span class="line"><span>UPDATE goods SET num=200 WHERE id&gt;1 AND id&lt;3;</span></span></code></pre></div></li><li><p>事务 B 将不能修改表中的 ID 大于 2 的记录</p><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BEGIN;</span></span>
<span class="line"><span>update goods set num =1 where id=2;</span></span>
<span class="line"><span>-- 阻塞中...</span></span></code></pre></div><p>但可以更改 ID 为 1 的记录</p><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>update goods set num =1 where id=1;</span></span></code></pre></div></li><li><p>执行添加时因为不在 id 为 1~3 的范围内所以可以添加，但如果添加时指定 ID 为 2 将会阻塞。</p><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>insert into goods (name,num) values(&#39;西瓜&#39;,200);</span></span></code></pre></div></li></ol><h2 id="悲观锁" tabindex="-1">悲观锁 <a class="header-anchor" href="#悲观锁" aria-label="Permalink to &quot;悲观锁&quot;">​</a></h2><p><strong>悲观锁</strong>指对数据被外界修改持保守态度，在整个数据处理过程中，将数据处于<strong>锁定状态</strong>，可以很好地解决并发事务的更新丢失问题。</p><p>下面演示商城下单情况，要用户购买商品后我们要减少库存，如果在高并发情况下多个用户同时修改库存表，会造成库存数据异常，使用悲观锁可以解决这个问题。</p><ol><li><p>事务 A 执行悲观锁操作后，其他事务执行同一代码时将阻塞</p><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BEGIN;</span></span>
<span class="line"><span>SELECT * FROM goods WHERE id=1 FOR UPDATE;</span></span>
<span class="line"><span>UPDATE goods SET num=num-2 WHERE id=1;</span></span>
<span class="line"><span>...</span></span></code></pre></div></li><li><p>事务 B 执行以下代码将不能查询库存，必须等事务 A 提交或回滚事务</p><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BEGIN;</span></span>
<span class="line"><span>## B事务中查询中也要使用 FOR UPDATE 悲观锁</span></span>
<span class="line"><span>SELECT * FROM goods WHERE id=1 FOR UPDATE;</span></span>
<span class="line"><span>-- 阻塞中...</span></span></code></pre></div></li><li><p>事务 A 提交后，事务 B 会得到事务 A 操作后的结果</p><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>...</span></span>
<span class="line"><span>COMMIT;</span></span>
<span class="line"><span>...</span></span></code></pre></div></li></ol><h2 id="乐观锁" tabindex="-1">乐观锁 <a class="header-anchor" href="#乐观锁" aria-label="Permalink to &quot;乐观锁&quot;">​</a></h2><p>在每次去拿数据的时候认为别人不会修改，不对数据上锁，但是在提交更新的时候会判断在此期间数据是否被更改，如果被更改则提交失败。</p><p>下面使用版本字段来实现乐观锁操作，并实现更改商品库存的案例。</p><ol><li><p>事务 A 查询商品库存，获取了商品记录，记录中有 VERSION 字段用于记录版本号（目前为 0）</p><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BEGIN;</span></span>
<span class="line"><span>SELECT * FROM goods WHERE id = 1;</span></span></code></pre></div></li><li><p>事务 B 同时查询，也获取了版本号为 0 的记录</p><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BEGIN;</span></span>
<span class="line"><span>SELECT * FROM goods WHERE id = 1;</span></span></code></pre></div></li><li><p>事务 A 更改库存，并增加版本号</p><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>UPDATE goods SET num=num-10,VERSION =VERSION+1 WHERE VERSION=0;</span></span></code></pre></div></li><li><p>事务 B 更改数据，但使用的是事务 B 查询到的 0 号版本，因为事务 A 已经提交版本号为 1，造成事务 B 修改失败，保证了数据的完整性。</p><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>UPDATE goods SET num=num-10,VERSION =VERSION+1 WHERE VERSION=0;</span></span></code></pre></div></li></ol><h2 id="表锁机制" tabindex="-1">表锁机制 <a class="header-anchor" href="#表锁机制" aria-label="Permalink to &quot;表锁机制&quot;">​</a></h2><p>针对一些不支持事务的处理引擎可以使用锁表的方式控制业务。</p><h4 id="读锁" tabindex="-1">读锁 <a class="header-anchor" href="#读锁" aria-label="Permalink to &quot;读锁&quot;">​</a></h4><p>为表设置读锁后，当前会话和其他会话都不可以修改数据，但可以读取表数据。</p><ol><li><p>会话 A 对表 goods 设置了读锁，将不能修改该表，也不能操作其他表</p><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LOCK TABLE goods READ;</span></span>
<span class="line"><span>UPDATE goods SET num=300 WHERE id=1;</span></span>
<span class="line"><span>SELECT * FROM stu;</span></span></code></pre></div></li><li><p>因为会话 A 对表<code>goods</code>设置了读锁，所以会话 B 也不能修改</p><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>update goods set num=200 where id=1;</span></span>
<span class="line"><span>-- 阻塞</span></span></code></pre></div></li><li><p>会话 A 解锁表后，其他会话又可以继续操作表了</p><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>UNLOCK TABLES;</span></span></code></pre></div></li></ol><h4 id="写锁" tabindex="-1">写锁 <a class="header-anchor" href="#写锁" aria-label="Permalink to &quot;写锁&quot;">​</a></h4><ol><li><p>为表设置了写锁后，当前会话可以修改，查询表，其他会话将无法操作。</p><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LOCK TABLE goods WRITE，stu WRITE;</span></span>
<span class="line"><span>INSERT INTO goods (name,num )VALUES(&#39;后盾人教程&#39;,300);</span></span></code></pre></div></li><li><p>会话 B 读取/写入表数据都将阻塞</p><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>select * from goods</span></span></code></pre></div></li><li><p>会话 A 解锁表数据后，其他会话都可以正常操作了</p><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>UNLOCK TABLES;</span></span></code></pre></div></li></ol>`,29)]))}const u=a(p,[["render",l]]);export{r as __pageData,u as default};
